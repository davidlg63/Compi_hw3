%{

#include <iostream>
#include "hw3_output.hpp"
#include "NonTerminalBase.h"
#include "SymbolTableManager.h"

#define YYSTYPE NonTerminalBase*;

int yylex();
void yyerror (const char*);
void InsertPrintFunctions();
extern int yylineno;
SymbolTableManager* symbolTableManager = new SymbolTableManager();

%}

%nonassoc VOID
%nonassoc INT
%nonassoc BYTE
%nonassoc B
%nonassoc BOOL
%nonassoc AUTO
%left OR
%left AND
%nonassoc TRUE
%nonassoc FALSE
%nonassoc RETURN
%right IF
%nonassoc WHILE
%nonassoc BREAK
%nonassoc CONTINUE
%nonassoc COMMA
%nonassoc SC
%nonassoc ID
%right ASSIGN
%left RELOP_EQUALITY
%left RELOP_RELATIONAL
%left BINOP_PLUS_MINUS
%left BINOP_MUL_DIV
%right NOT
%nonassoc NUM
%nonassoc STRING
%left LPAREN
%left RPAREN
%left LBRACE
%left RBRACE
%right ELSE
%%
    Program: {symbolTableManager->openScope(); InsertPrintFunctions();} Funcs	{output::printProductionRule(1);}
	;
	
    Funcs: /*epsilon*/ 	{output::printProductionRule(2);} |
			FuncDecl Funcs	{output::printProductionRule(3);}
			;
			
			
    FuncDecl: RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE	{output::printProductionRule(4);}
	;
	
	
    RetType: Type	{output::printProductionRule(5);} |
			 VOID	{output::printProductionRule(6);}
			 ;
			 
			 
    Formals: /*epsilon*/	{output::printProductionRule(7);} |
             FormalsList	{output::printProductionRule(8);}
			 ;
			 
			 
    FormalsList: FormalDecl	{output::printProductionRule(9);} |
				FormalDecl COMMA FormalsList {output::printProductionRule(10);}
				;
				
				
    FormalDecl: Type ID	{output::printProductionRule(11);}
	;
	
	
    Statements: Statement	{output::printProductionRule(12);} |
				Statements Statement	{output::printProductionRule(13);}
				;
				
				
	Statement:
				LBRACE {symbolTableManager->openScope();} Statements RBRACE	{symbolTableManager->closeScope();} |
				Type ID SC	{output::printProductionRule(15);} |
				Type ID ASSIGN Exp SC	{output::printProductionRule(16);} |
				AUTO ID ASSIGN Exp SC	{output::printProductionRule(17);} |
				ID ASSIGN Exp SC	{output::printProductionRule(18);} |
				Call SC	{output::printProductionRule(19);} |
				RETURN SC	{output::printProductionRule(20);} |
				RETURN Exp SC	{output::printProductionRule(21);} |
				IF IF_Marker LPAREN Exp RPAREN Statement  {symbolTableManager->closeScope();} |                               
				IF IF_Marker LPAREN Exp RPAREN Statement ELSE {symbolTableManager->openScope();} Statement	{symbolTableManager->closeScope();} |
				WHILE {symbolTableManager->openScope();} LPAREN Exp RPAREN Statement	{symbolTableManager->closeScope();} |
				BREAK SC	{output::printProductionRule(25);} |
				CONTINUE SC	{output::printProductionRule(26);}
				;
	
	
    Call: ID LPAREN ExpList RPAREN	{output::printProductionRule(27);} |
		  ID LPAREN RPAREN	{output::printProductionRule(28);}
		  ;
		  
    ExpList: Exp	{output::printProductionRule(29);} |
		   	 Exp COMMA ExpList	{output::printProductionRule(30);}
			 ;
			 
			 
    Type: INT	{output::printProductionRule(31);} |
		  BYTE	{output::printProductionRule(32);} |
       	  BOOL	{output::printProductionRule(33);}
		  ;
		  
		  
    Exp: LPAREN Exp RPAREN	{output::printProductionRule(34);}	|
         Exp BINOP_PLUS_MINUS Exp	{output::printProductionRule(35);} |
		 Exp BINOP_MUL_DIV Exp	{output::printProductionRule(35);} |
         ID          	{output::printProductionRule(36);} |
         Call        	{output::printProductionRule(37);} |
         NUM         	{output::printProductionRule(38);} |
         NUM B       	{output::printProductionRule(39);} |
         STRING      	{output::printProductionRule(40);} |
         TRUE        	{output::printProductionRule(41);} |
         FALSE       	{output::printProductionRule(42);} |
         NOT Exp     	{output::printProductionRule(43);} |
         Exp AND Exp 	{output::printProductionRule(44);} |
         Exp OR Exp		{output::printProductionRule(45);} |
         Exp RELOP_EQUALITY Exp  {output::printProductionRule(46);} |
		 Exp RELOP_RELATIONAL Exp  {output::printProductionRule(46);} |
         LPAREN Type RPAREN Exp	{output::printProductionRule(47);}
		 ;
		 
	IF_Marker: /*epsilon*/ {symbolTableManager->openScope();}
		 

%%

int main()
{
    return yyparse();
}

void yyerror(const char* message)
{
    output::errorSyn(yylineno);
    exit(1);
}

void InsertPrintFunctions()
{
	std::shared_ptr<SymbolTable> currentTable = symbolTableManager->top();
	std::vector<Type_> printParams = std::vector<Type_>(1, Type_::TYPE_STRING);
	currentTable->Insert("print", Type_::TYPE_VOID, 0, printParams);
	std::vector<Type_> printIParams = std::vector<Type_>(1, Type_::TYPE_INT);
	currentTable->Insert("printi", Type_::TYPE_VOID, 0, printIParams);
}